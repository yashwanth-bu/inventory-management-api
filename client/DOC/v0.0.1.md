# Inventory Management Frontend Documentation [VERSION 0.0.1]

## 1. Frontend Overview

The frontend is a React + Vite application that connects to the Inventory Management API and provides:
* Inventory listing
* Search (server-side query)
* Create inventory
* Soft delete inventory
* Recover deleted inventory
* Active vs Deleted views
* API-driven state refresh
* All data operations are API-backed — no mock or local-only state.

## 2. Tech Stack (Logical Layer)

* React (functional components + hooks)
* Vite (build tool)
* Axios (HTTP client)
* React Router (page routing)
* React Hot Toast (event feedback)
* TailwindCSS (styling — not covered here)

## 3. Frontend Project Structure (Logical)
client/src/

 ├─ api/
 │   └─ inventoryApi.js            # All HTTP calls to backend
 ├─ pages/
 │   ├─ InventoryPage.jsx          # Active inventory workspace
 │   └─ DeletedInventoryPage.jsx   # Deleted inventory workspace
 ├─ components/
 │   ├─ InventoryTable.jsx         # Active inventory list renderer
 │   └─ AddInventoryForm.jsx       # Create inventory modal/form
 ├─ App.jsx                        # Router + layout shell
 └─ main.jsx                       # App bootstrap

## 4. Routing Logic
Routing is handled using React Router.

Route	             Component	                      Purpose
/	                 InventoryPage	                  Active inventories
/deleted	         DeletedInventoryPage	          Soft-deleted inventories

Defined in:
<Routes>
  <Route path="/" element={<InventoryPage />} />
  <Route path="/deleted" element={<DeletedInventoryPage />} />
</Routes>

## 5. API Layer (Centralized)
All backend communication is centralized in:

* api/inventoryApi.js

Axios instance:
```js
const API = axios.create({
  baseURL: "http://localhost:3000/api/inventory"
});
```

### Functions
* Function	                                   Endpoint
* getAllInventory(params)	                   GET / with optional query
* getInventoryById(id)	                       GET /:id
* getDeletedInventory()	                       GET /deleted
* getInventoryByName(name)	                   GET /by-name/:name
* createInventory(data)	                       POST /
* updateInventory(id,data)	                   PATCH /:id
* deleteInventory(id)	                       DELETE /:id
* recoverInventory(id)	                       PATCH /:id/recover

## 6. InventoryPage Logic Flow
File: pages/InventoryPage.jsx

### State
* items      → inventory list
* loading    → loading flag
* error      → load error
* search     → search query
* showCreate → modal visibility

Data Load Function
```js
const loadData = async () => {
  const res = await getAllInventory(
    search ? { name: search } : undefined
  );
  setItems(res.data.data || []);
}
```

### Search Logic

* Controlled input
* Debounced with timeout
* Calls API with ?name=query
* Server performs filtering

```js
useEffect(() => {
  const t = setTimeout(loadData, 350);
  return () => clearTimeout(t);
}, [search]);
```

### Create Flow
+ New → opens modal → submit → POST → reload list
AddInventoryForm → createInventory → onCreated → loadData()

### Delete Flow
Delete button → DELETE API → reload list

Handled inside table component via callback:
onDeleted → loadData()

## 7. InventoryTable Logic
File: components/InventoryTable.jsx

Responsibilities:
* Receives items array
* Maps rows
* Handles delete action
* Triggers parent reload

```js
items.map(item => ...)
```

Delete handler:
```js
await deleteInventory(id)
onDeleted()
```

## 8. AddInventoryForm Logic
File: components/AddInventoryForm.jsx

* Responsibilities:
* Controlled input state
* POST create request
* Success toast
* Reset form
* Close modal
* Trigger reload callback

```js
await createInventory({ name })
onCreated()
```

## 9. DeletedInventoryPage Logic
File: pages/DeletedInventoryPage.jsx

Load Deleted Records
```js
const res = await getDeletedInventory();
setItems(res.data.data || []);
```

### Recover Flow
* Recover button → PATCH /:id/recover → reload

```js
await recoverInventory(id)
loadData()
```

## 10. State Refresh Strategy
The app uses server-truth refresh instead of local mutation.
### After every mutation:
* create
* delete
* recover
* update (future)

→ call loadData() again
→ re-fetch list from backend

## 11. Error Handling Strategy
* API errors caught in try/catch
* Toast messages for user feedback
* Fallback empty arrays used: 
  -> res.data.data || []
  Prevents render crashes.


## 12. Search Contract Alignment
### Frontend sends:
GET /api/inventory?name=query

### Backend performs:
contains + case-insensitive search
deletedAt = null filter

### Frontend expects:
array result (possibly empty)

## 13. Frontend–Backend Contract Rules
Frontend assumes:
* API always returns { success, message, data }
* data is array for list endpoints
* soft-deleted items excluded from active list
* search handled server-side